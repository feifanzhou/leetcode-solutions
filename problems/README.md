My goal is to illustrate different ways of thinking through each problem to get to a working solution, not necessarily to present the most optimal solution (although many solutions are likely to be optimal). I've found that you can train your brain to recognize certain tools and patterns (like using binary numbers to represent state, or implementing a BFS with a queue) which can then be used to solve problems you haven't seen before.

I'll be presenting solutions in Ruby because it's my favorite. It can also be a very expressive language, and I'm going to optimize for expressiveness. This means my code here will feature more classes, longer method names, and more helper methods than you'd necessarily write in the time-constrained context of a real interview. It's always easier to read and understand more expressive code and make it terse when you need to, than to go the other way.